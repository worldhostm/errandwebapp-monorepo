# 심부름 조회 로직 분석 문서

## 개요
현재 심부름 웹앱에서 지도에 표시되는 심부름과 목록에 표시되는 심부름의 조회 기준과 로직에 대한 분석 문서입니다.

## 1. 지도에 표시되는 심부름 조회 로직

### API 엔드포인트
- **URL**: `/api/errands/nearby`
- **메서드**: GET
- **컨트롤러**: `errandController.ts:getNearbyErrands` (33-85행)

### 조회 기준
1. **지리적 위치 기반 조회**
   - MongoDB의 `$near` 연산자 사용
   - 지도 중심점 기준으로 반경 내 조회
   - 기본 반경: 5km (5000m)
   - 확장 반경: 50km (50000m)

2. **필터링 조건**
   ```typescript
   const query: any = {
     status: 'pending',  // 대기중인 심부름만
     location: {
       $near: {
         $geometry: {
           type: 'Point',
           coordinates: [longitude, latitude]
         },
         $maxDistance: radiusInMeters
       }
     }
   };
   
   // 자신의 심부름 제외 (로그인한 경우)
   if (user) {
     query.requestedBy = { $ne: user._id };
   }
   ```

3. **정렬 및 제한**
   - `createdAt: -1` (최신순)
   - 페이지네이션 지원 (기본 20개 제한)

### 프론트엔드 호출 시점
- **지도 이동 시**: `Map.tsx:debouncedOnMapMove` (129-171행)
- **사용자 위치 변경 시**: `page.tsx:fetchErrandsAtLocation` (132-189행)
- **줌 레벨 변경 시**: 지도 이동과 동일한 로직 적용

### 디바운싱 및 최적화
- **0.8초 디바운스**: 지도 드래그 중 과도한 API 호출 방지
- **최소 이동 거리**: 200m 미만 이동 시 재조회 생략
- **AbortController**: 이전 요청 취소로 중복 요청 방지

## 2. 목록에 표시되는 심부름 조회 로직

### 2-1. 메인 페이지 심부름 목록 (receiver 탭)

#### 조회 로직
- **동일한 API 사용**: `/api/errands/nearby`
- **지도와 동일한 조건**: 위치 기반 + 상태 필터링

#### 필터링 추가 로직 (`page.tsx:fetchErrandsAtLocation`)
```typescript
// 현재 지도 bounds가 있으면 해당 범위 내의 심부름만 표시
let finalErrands = processed
if (currentMapBounds) {
  finalErrands = processed.filter(errand => {
    return errand.lat >= currentMapBounds.sw.lat && errand.lat <= currentMapBounds.ne.lat &&
           errand.lng >= currentMapBounds.sw.lng && errand.lng <= currentMapBounds.ne.lng
  })
}
```

#### 표시되는 심부름
- 지도 화면 범위 내에 있는 심부름만 목록에 표시
- 거리순 정렬 (`processErrands`에서 처리)

### 2-2. 내가 수행하는 심부름 (performer 탭)

#### API 엔드포인트
- **URL**: `/api/errands/user?type=accepted`
- **컨트롤러**: `errandController.ts:getUserErrands` (195-246행)

#### 조회 기준
```typescript
const query: any = {
  acceptedBy: user._id,  // 내가 수락한 심부름
  // status 필터링은 프론트엔드에서 처리
};
```

#### 필터링
- **상태별 필터**: all, accepted, in_progress, completed
- **위치 무관**: 지리적 위치와 상관없이 내가 수락한 모든 심부름

### 2-3. 내가 등록한 심부름 (requester 탭)

#### API 엔드포인트
- **URL**: `/api/errands/user?type=requested`
- **컨트롤러**: 동일한 `getUserErrands` 함수

#### 조회 기준
```typescript
const query: any = {
  requestedBy: user._id,  // 내가 등록한 심부름
};
```

## 3. 지도와 목록 간의 차이점 분석

### 현재 상황
1. **지도 표시 심부름**: 지도 bounds 내 + 위치 기반 조회 결과
2. **목록 표시 심부름**: 동일한 데이터에서 bounds 필터링 적용

### 문제점
- **동기화됨**: 지도와 목록이 같은 API 호출 결과를 사용하므로 일치함
- **bounds 필터링**: 지도 화면 밖 심부름은 목록에서도 제외됨

## 4. 해결 방안: 지도 밖 심부름을 목록에서 숨기기

### 현재 로직의 변경점
`page.tsx:fetchErrandsAtLocation` 함수에서 이미 구현되어 있습니다:

```typescript
// 164-171행: bounds 필터링
if (currentMapBounds) {
  finalErrands = processed.filter(errand => {
    return errand.lat >= currentMapBounds.sw.lat && errand.lat <= currentMapBounds.ne.lat &&
           errand.lng >= currentMapBounds.sw.lng && errand.lng <= currentMapBounds.ne.lng
  })
  console.log(`📍 bounds 필터링 (fetchErrandsAtLocation): ${processed.length}개 → ${finalErrands.length}개`)
}
```

### 추가 최적화 방안
1. **API 레벨에서 bounds 필터링**: 
   - 클라이언트에서 bounds 정보를 API로 전달
   - 서버에서 직접 bounds 내 심부름만 조회
   - 네트워크 트래픽 감소

2. **캐싱 전략**:
   - 지역별 심부름 데이터 캐싱
   - 지도 이동 시 캐시된 데이터 활용

## 5. 코드 위치 참조

### Backend
- **라우터**: `apps/backend/src/routes/errands.ts:20` - GET /nearby
- **컨트롤러**: `apps/backend/src/controllers/errandController.ts:33-85` - getNearbyErrands
- **사용자 심부름**: `apps/backend/src/controllers/errandController.ts:195-246` - getUserErrands

### Frontend
- **메인 페이지**: `apps/frontend/app/page.tsx:132-189` - fetchErrandsAtLocation
- **지도 컴포넌트**: `apps/frontend/app/components/Map.tsx:129-171` - debouncedOnMapMove
- **API 클라이언트**: `apps/frontend/app/lib/api.ts:83-94` - getNearbyErrands
- **수행 심부름**: `apps/frontend/app/components/MyAcceptedErrands.tsx:60-84` - fetchMyAcceptedErrands

## 6. 요약

**현재 상태**: 지도 밖 심부름은 이미 목록에서 제외됩니다.
- 지도와 목록이 동일한 데이터셋 사용
- 지도 bounds 기준으로 필터링 적용
- 사용자가 지도를 이동하면 해당 지역 심부름만 목록에 표시

**개선 제안**: 현재 로직이 요구사항을 만족하므로 추가 변경이 불필요하나, 성능 최적화를 위해 서버 레벨 bounds 필터링 고려 가능합니다.